# 正则表达式

[Javascript正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)

## 简单模式

无特殊字符的字符串匹配

```javascript
var regexp = new RegExp("abc");
regexp.exec("aaaaaaabcccccc");
```

## 特殊字符

<table>
  <tr></tr>
    <td>字符</td>
    <td>含义</td>
  <tr><td>\</td><td>
    将其后的字符转义为字面量。<br/>
    例如模式/a*/可以匹配0个或多个a，而模式/a\*/将*的特殊性移除，可以匹配"a*"这样的字符串
  </td></tr>
  <tr><td>^</td><td>
    匹配输入的开始
  </td></tr>
  <tr><td>$</td><td>
    匹配输入的结束
  </td></tr>
  <tr><td>*</td><td>
    匹配前一个表达式0次或者多次，等价于{0,}
  </td></tr>
  <tr><td>+</td><td>
    匹配前一个表达式1次或者多次，等价于{1,}
  </td></tr>
  <tr><td>{n}</td><td>
    n是一个正整数，匹配前一个字符恰好发生了n次
  </td></tr>
  <tr><td>{n,m}</td><td>
    n和m都是整数，匹配前一个字符至少发生n次，至多m次
  </td></tr>
  <tr><td>?</td><td>
    匹配前一个表达式0次或者1次，等价于{0,1}<br/>
    如果紧跟在任何量词* + ? {}后面，将会使量词变为非贪婪的（匹配尽量少的字符）
  </td></tr>
  <tr><td>.</td><td>
    匹配除换行符之外的任意其他字符
  </td></tr>
  <tr><td>x(?=y)</td><td>
    先行断言，匹配x仅仅当x后面紧跟y。<br/>
    /Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。
  </td></tr>
  <tr><td>(?<=y)x</td><td>
    后行断言，匹配x仅仅当x前面是y。
  </td></tr>
  <tr><td>x(?!y)</td><td>
    正向否定查找，匹配x仅仅当后面跟的不是y。
  </td></tr>
  <tr><td>x|y</td><td>
    匹配x或者y。
  </td></tr>
  <tr><td>[xyz]</td><td>
    字符集合，匹配方括号中的任意字符，(. *)这样的特殊字符在方括号中不需要转义。我们可以使用破折号(-)来表示范围。例如，[a-z]。
  </td></tr>
  <tr><td>[^xyz]</td><td>
    反向字符集，不匹配方括号中的任意字符。
  </td></tr>
  <tr><td>[\b]</td><td>
    匹配一个退格。
  </td></tr>
  <tr><td>\b</td><td>
    匹配一个词的边界，表示词的开头或者是结尾。
  </td></tr>
  <tr><td>\B</td><td>
    TODO
  </td></tr>
  <tr><td>\cX</td><td>
    如果x是A-Z之间的字符，匹配字符串中的一个控制符。<br/>
    /\cM/匹配字符串中的control-M
  </td></tr>
  <tr><td>\d</td><td>
    匹配一个数字，等价于[0-9]
  </td></tr>
  <tr><td>\D</td><td>
    匹配一个非数字，等价于[^0-9]。
  </td></tr>
  <tr><td>\f</td><td>
    匹配一个换页符。
  </td></tr>
  <tr><td>\n</td><td>
    匹配一个换行符。
  </td></tr>
  <tr><td>\r</td><td>
    匹配一个回车符。
  </td></tr>
  <tr><td>\s</td><td>
    匹配一个空白符，包括空格，制表位，换页符，换行符。
  </td></tr>
  <tr><td>\S</td><td>
    匹配一个回车符。
  </td></tr>

</table>
 



\bhi\b
\b 是元字符，metacharacter，代表著單詞的開頭或結尾

\bhi\b.*zhiming
.是元字符，匹配除了換行符以外的任意字符
*是元字符，表示數量，任意數量

0\d{2}-\d{8}
\d 表示匹配數字
{2} {8} 表示匹配的次數
{2, 8} 表示匹配的次數為2-8次

\s 匹配任意的空白符，包括空格，製表符，換行符，中文全角空格
\w 匹配字母，數字，下劃線，漢字
^ 匹配字符串的開始
$ 匹配字符串的結束
* 重複0次或更多次
+ 重複1次或更多次
? 重複0次或1次
{n} 重複n次
{n,} 重複n次或更多次
{n, m} 重複n到m次

google\.com => 匹配 google.com
C:\\windows => 匹配 C:\windows
使用 \ 可以取消元字符的特殊意義，這樣我們就能對元字符進行匹配了。

複雜的正則表達式：
\(?0\d{2}[) -]?\d{8}

分支條件
0\d{2}-\d{8}|0\d{3}-\d{7}
用 | 把不同的規則分隔開，滿足任意條件都可以認為是滿足該正則表達式

分組
分組可以實現重複多個字符的情況，比如：IP地址的正則表達式的寫法：
(2[0-4]\d|25[0-5]|[01]?\d\d?\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)

反義
\W 匹配任意不是字母，數字，下劃線，漢字的字符
\S 匹配任意不是空白符的字符
\D 匹配任意非數字的字符
\B 匹配不是單詞開頭或結束的位置
[^x] 匹配除x以外的任意字符
[^aeiou] 匹配除aeiou這幾個字母以外的任意字符

後向引用
用於重複搜索前面某個分組匹配的文本。\1 表示分組1匹配的文本。
\b(\w+)\b\s+\1
該正則表達式可以用來匹配重複的單詞，比如go go
自定義組名，(?<name>\w+)，這樣就把 \w+ 的組名指定為name。
要後向引用這個分組捕獲的內容可以使用，\k<name>

分組語法：
(exp) 匹配exp，並捕獲文本到自動命名的組裡。
(?<name>exp) 匹配exp，並捕獲文本到名稱為name的組裡。也可以寫成(?'name'exp)
(?:exp) 匹配exp，不捕獲匹配的文本，也不給此分組分配組號

註釋
(?#comment) 這種類型的分組不對正則表達式造成任何影響，用於提供註釋讓人閱讀

零寬斷言
(?=exp) 匹配exp前面的位置
(?<=exp) 匹配exp後面的位置

負向零寬斷言
(?!exp) 匹配後面跟的不是exp的位置
(?<!exp) 匹配前面不是exp的位置

貪婪
正則表達式在默認情況下會匹配盡可能多的字符，比如：a.*b。如果用該表達式來匹配aaabbabb，那麼將會匹配整個字符串。

懶惰
避免正則表達式的貪婪匹配，我們可以在一些地方加 ?
*? 重複任意次，盡可能少重複
+? 重複1次或多次，盡可能少重複
?? 重複0次或1次，但盡可能少重複
{n, m}? 重複n到m次，但盡可能少重複
{n,}? 重複n次以上，但盡可能少重複
